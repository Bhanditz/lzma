// Copyright (c) 2010, Andrei Vieru. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lzma

import (
	"bytes"
	"io"
	"os"
	"testing"
)

type unlzmaTest struct {
	descr string
	raw   string
	lzma  []byte
	err   os.Error
}

var unlzmaTests = []unlzmaTest{
	// hexdump -Cv empty.lzma | awk '{for (i=2; i<18; i++) printf("0x%s, ", $i); printf("\n")}'
	unlzmaTest{
		"empty test",
		"",
		[]byte{
			0x5d, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00,
		},
		nil,
	},
	unlzmaTest{
		"empty (with size == -1) test",
		"",
		[]byte{
			0x5d, 0x00, 0x00, 0x80, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x83, 0xff,
			0xfb, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00,
		},
		nil,
	},
	unlzmaTest{
		"hello world test",
		"hello world\n",
		[]byte{
			0x5d, 0x00, 0x00, 0x80, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x19,
			0x49, 0xee, 0x8d, 0xe9, 0x17, 0x89, 0x3a, 0x33, 0x5f, 0xfc, 0xac, 0xf7, 0x20, 0x00,
		},
		nil,
	},
	unlzmaTest{
		"hello world (with size == -1) test",
		"hello world\n",
		[]byte{
			0x5d, 0x00, 0x00, 0x80, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x34, 0x19,
			0x49, 0xee, 0x8d, 0xe9, 0x17, 0x89, 0x3a, 0x33, 0x5f, 0xfc, 0xb2, 0x09, 0x82, 0x2f, 0xff, 0xfd,
			0xe2, 0x80, 0x00,
		},
		nil,
	},
	unlzmaTest{
		"hello world test with corrupt lc, lp, pb in header",
		"hello world\n",
		[]byte{
			0xfe, 0x00, 0x00, 0x80, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34, 0x19,
			0x49, 0xee, 0x8d, 0xe9, 0x17, 0x89, 0x3a, 0x33, 0x5f, 0xfc, 0xac, 0xf7, 0x20, 0x00,
		},
		headerError,
	},
}

func TestDecoder(t *testing.T) {
	b := new(bytes.Buffer)
	for _, tt := range unlzmaTests {
		in := bytes.NewBuffer(tt.lzma)
		r := NewDecoder(in)
		defer r.Close()
		b.Reset()
		n, err := io.Copy(b, r)
		if err != tt.err {
			t.Errorf("%s: io.Copy: %v, want %v", tt.descr, err, tt.err)
		}
		if err == nil { // if err != nil, there is little chance that data is decoded correctly, if at all
			s := b.String()
			if s != tt.raw {
				t.Errorf("%s: got %d-byte %q, want %d-byte %q", tt.descr, n, s, len(tt.raw), tt.raw)
			}
		}
	}
}
